sqlite_auto_view <- function(table_pragma, target_table, relationships) {
  tmp <- table_pragma %>%
    left_join(relationships, by = c("name" = "fk_col")) %>%
    select(name, norm_table:val_col) %>%
    mutate(lhs = str_c(target_table, name, sep = "."),
           rhs_val = str_c(norm_table, val_col, sep = "."),
           rhs_join = str_c(norm_table, pk_col, sep = "."),
           select_comment = str_c("/* ",
                                  ifelse(is.na(norm_table), "Direct use column", "Normalized value column"),
                                  " '",
                                  ifelse(is.na(norm_table), name, val_col),
                                  "' from table '",
                                  ifelse(is.na(norm_table), target_table, norm_table),
                                  "'. */"),
           sql_select = str_c(ifelse(is.na(norm_table), lhs, rhs_val),
                              " AS ", name, ", ", 
                              select_comment),
           sql_join = ifelse(is.na(norm_table),
                             NA,
                             str_c("LEFT JOIN ",
                                   ifelse(is.na(norm_table),
                                          NA,
                                          norm_table),
                                   " ON ", lhs, " = ", rhs_join))
    )
  tmp$sql_select[length(tmp$sql_select)] <- gsub(", /\\*", " /\\*", tmp$sql_select[length(tmp$sql_select)])
  norm_tables <- format_list_of_names(unique(tmp$norm_table[!is.na(tmp$norm_table)]), add_quotes = TRUE)
  view_comment <- glue::glue("/* [autogenerated] View of '{target_table}' normalized by {norm_tables}. */")
  target_columns <- paste0(tmp$sql_select, collapse = " ")
  norm_tables_join <- paste0(tmp$sql_join[!is.na(tmp$sql_join)], collapse = " ")
  view_sql <- glue::glue("CREATE VIEW IF NOT EXISTS view_{target_table} AS {view_comment} SELECT {target_columns} FROM {target_table} {norm_tables_join};")
  return(view_sql)
}

#' Build SQL to create views on normalized tables in SQLite
#' 
#' @inheritParams get_fkpk_relationships
#' 
#' @param save_to_file 
#' @param append LGL scalar
#'
#' @return
#' @export
#'
#' @examples
build_views <- function(db_map, references_in = "references", dictionary = db_dict, save_to_file = NULL, append = TRUE) {
  stopifnot(is.list(db_map),
            is.character(references_in),
            length(references_in) == 1,
            is.list(dictionary),
            is.logical(append),
            length(append) == 1,
            any(is.null(save_to_file),
                is.character(save_to_file) & length(save_to_file) == 1))
  fk_relationships <- get_fkpk_relationships(db_map, references_in)
  table_names <- names(fk_relationships)
  dictionary <- dictionary[table_names]
  views <- lapply(table_names,
                  function(x) {
                    sqlite_auto_view(
                      table_pragma = dictionary[[x]],
                      target_table = x,
                      relationships = fk_relationships[[x]])
                  }) %>%
    setNames(table_names)
  if (is.null(save_to_file)) {
    return(views)
  } else {
    # TODO readr::write_file(triggers, save_to_file)
  }
}

#' Extract foreign key relationships from a schema
#'
#' This convenience function is part of the automatic generation of SQL commands
#' building views and triggers from a defined schema. Its sole purpose is as a
#' pre-pass extraction of foreign key relationships between tables from an
#' object created by [db_map], which in turn relies on specific formatting in
#' the schema SQL definitions.
#'
#' @note This only functions for list objects formatted correctly. That is, each
#'   entry in [db_map] must contain an element with a name matching that
#'   provided to `references_in` which contains a character vector formatted as
#'   "table1 REFERENCES table2(pk_column)".
#'
#' @param db_map  LIST object containing descriptions of table mapping in an
#'   opinionated manner, generally generated by [er_map]. The expectation is a
#'   list of tables, with references in SQL form enumerated in a child element
#'   with a name matching `references_in`
#' @param references_in CHR scalar naming the child element containing SQL
#'   references statements of the form "fk_column REFERENCES table(pk_column)"
#'   (default: "references" is provided by [er_map])
#' @param dictionary LIST object containing the schema dictionary produced by
#'   [data_dictionary] fully describing table entities
#'
#' @return LIST of data frames with one element for each table with a foreign
#'   key defined
#' @export
#'
#' @examples
#' \dontrun{get_fkpk_relationships(er_map(db_conn = con))}
get_fkpk_relationships <- function(db_map, references_in = "references", dictionary = db_dict) {
  stopifnot(is.character(references_in),
            is.list(db_map),
            length(references_in) == 1)
  if (references_in %in% names(db_map)) {
    db_map <- list(db_map)
    names(db_map) <- db_map[[1]]$object_name
  }
  fk_relationships <- lapply(db_map, function(x) if (references_in %in% names(x)) x[[references_in]])
  fk_relationships <- fk_relationships[sapply(fk_relationships, length) > 0]
  fk_relationships <- lapply(fk_relationships,
                             function(x) {
                               x %>%
                                 stringr::str_remove_all("\\)") %>%
                                 as.data.frame() %>%
                                 setNames("one") %>%
                                 tidyr::separate(one,
                                                 into = c("fk_col", "norm_table", "pk_col"),
                                                 sep = " REFERENCES |\\(") %>%
                                 dplyr::filter(grepl("norm", .$norm_table))
                             })
  fk_relationships <- fk_relationships[sapply(fk_relationships, nrow) > 0]
  tables <- names(fk_relationships)
  fk_relationships <- lapply(tables,
                             function(x) {
                               norm_tables <- fk_relationships[[x]]
                               for (nt in 1:nrow(norm_tables)) {
                                 table_cols <- dictionary[[norm_tables$norm_table[[nt]]]]$name
                                 table_cols <- table_cols[table_cols != norm_tables$pk_col[nt]]
                                 norm_tables$val_col[nt] <- table_cols[1]
                                 return(norm_tables)
                               }
                             }) %>%
    setNames(tables)
  return(fk_relationships)
}
