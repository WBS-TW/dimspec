% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NIST_import_routines.R
\name{resolve_fragments_NTAMRT}
\alias{resolve_fragments_NTAMRT}
\title{Resolve the fragments node during database import}
\usage{
resolve_fragments_NTAMRT(
  obj,
  sample_id = NULL,
  generation_type = NULL,
  fragments_in = "annotation",
  fragments_table = "annotated_fragments",
  fragments_norm_table = ref_table_from_map(fragments_table, "fragment_id"),
  fragments_sources_table = "fragment_sources",
  citation_info_in = "fragment_citation",
  inspection_info_in = "fragment_inspections",
  inspection_table = "fragment_inspections",
  generate_missing_aliases = FALSE,
  fragment_aliases_in = "fragment_aliases",
  fragment_aliases_table = "fragment_aliases",
  alias_type_norm_table = ref_table_from_map(fragment_aliases_table, "alias_type"),
  inchi_prefix = "InChI=1S/",
  rdkit_name = ifelse(exists("PYENV_NAME"), PYENV_NAME, "rdkit"),
  rdkit_ref = ifelse(exists("PYENV_REF"), PYENV_REF, "rdk"),
  rdkit_ns = "rdk",
  rdkit_make_if_not = TRUE,
  rdkit_aliases = c("Inchi", "InchiKey"),
  mol_to_prefix = "MolTo",
  mol_from_prefix = "MolFrom",
  type = "smiles",
  import_map = IMPORT_MAP,
  case_sensitive = FALSE,
  fuzzy = FALSE,
  strip_na = TRUE,
  db_conn = con,
  log_ns = "db"
)
}
\arguments{
\item{obj}{LIST object containing data formatted from the import generator}

\item{sample_id}{INT scalar matching a sample ID to which to tie these
fragments (optional, default: NULL)}

\item{generation_type}{CHR scalar containing the generation type as defined
in the "norm_generation_type" table (default: NULL will obtain the
generation type attached to the `sample_id` by database lookup)}

\item{fragments_in}{CHR scalar name of the `obj` component holding annotated
fragment information (default: "annotation")}

\item{fragments_table}{CHR scalar name of the database table holding
annotated fragment information (default: "annotated_fragments")}

\item{fragments_norm_table}{CHR scalar name of the database table holding
normalized fragment identities (default: obtains this from the result of a
call to [er_map] with the table name from `fragments_table`)}

\item{fragments_sources_table}{CHR scalar name of the database table holding
fragment source (e.g. generation) information (default: "fragment_sources")}

\item{citation_info_in}{CHR scalar name of the `obj` component holding
fragment citation information (default: "fragment_citation")}

\item{inspection_info_in}{CHR scalar name of the `obj` component holding
fragment inspection information (default: "fragment_inspections")}

\item{inspection_table}{CHR scalar name of the database table holding
fragment inspection information (default: "fragment_inspections")}

\item{generate_missing_aliases}{LGL scalar determining whether or not to
generate machine readable expressions (e.g. InChI) for fragment aliases
from RDKit (requires RDKit activation; default: FALSE); see formals list
for [add_rdkit_aliases]}

\item{fragment_aliases_in}{CHR scalar name of the `obj` component holding
fragment aliases (default: "fragment_aliases")}

\item{fragment_aliases_table}{CHR scalar name of the database table holding
fragment aliases (default: "fragment_aliases")}

\item{rdkit_ref}{CHR scalar OR R object of an RDKit binding (default NULL
goes to "rdk" for convenience with other pipelines in this project)}

\item{mol_to_prefix}{CHR scalar of the prefix to identify an RDKit function
to create an alias from a mol object (default: "MolTo")}

\item{mol_from_prefix}{CHR scalar of the prefix to identify an RDKit function
to create a mol object from`identifiers` (default: "MolFrom")}

\item{type}{CHR scalar of the type of encoding to use for `identifiers`
(default: smiles)}

\item{import_map}{data.frame object of the import map (e.g. from a CSV)}

\item{case_sensitive}{LGL scalar of whether to match on a case sensitive
basis (the default TRUE searches for values as-provided) or whether to
coerce value matches by upper, lower, sentence, and title case matches}

\item{fuzzy}{LGL scalar of whether to do a "fuzzy" match in the sense that
values provided are wrapped in an SQL "LIKE '%value%'" clause; overrides
the `case_sensitive` setting if TRUE (default: FALSE).}

\item{db_conn}{connection object (default: con)}

\item{log_ns}{CHR scalar of the logging namespace to use (default: "db")}

\item{fragment_alias_type_norm_table}{CHR scalar name of the database table
holding normalized fragment alias type identities (default: obtains this
from the result of a call to [er_map] with the table name from
`fragment_aliases_table`)}
}
\value{
INT vector of resolved annotated fragment IDs; executes database
  actions
}
\description{
Call this function as part of an import routine to resolve the fragments node
including fragment inspections and aliases. If the python connection to RDKit
is available and no aliases are provided, aliases as defined in
`rdkit_aliases` will be generated and stored if `generate_missing_aliases` is
set to TRUE. Components of the import file will be collated, have their
values normalized, and any new fragment identifiers will be added to the
database.
}
\details{
Fragments missing structure annotation are supported (e.g. those with a
formula but no SMILES notation provided).

For new fragments, the calculated molecular mass is generated by
[calculate.monoisotope] from exact masses of each constituent atom. If RDKit
is available and a SMILES notation is provided, the formal molecular net
charge is also calculated via rdkit.Chem.GetFormalCharge.

Database tables affected by resolving the fragments node include:
annotated_fragments, norm_fragments, fragment_inspections, fragment_aliases,
and fragment_sources.
}
\note{
This function is called as part of [full_import()]

If components named in `citation_info_in` and `inspection_info_in` do
  not exist, that information will not be appended to the resulting database
  records.

Typical usage as part of the import workflow involves simply passing
  the import object and associated sample id: resolve_fragments_NTAMRT(obj =
  import_object, sample_id = 1), though wrapper functions like [full_import]
  also contain name-matched arguments to be passed in a [do.call] context.
}
