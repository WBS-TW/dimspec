% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/app_functions.R
\name{verify_args}
\alias{verify_args}
\title{Verify arguments for a function}
\usage{
\preformatted{ verify_args(args = list(character_length_2 = c("a",
"b")), conditions = list(character_length_2 = list(c("mode", "character"),
c("length", 3)) ) verify_args(args = list(boolean = c(TRUE, FALSE, TRUE)),
conditions = list(list(c("mode", "logical"), c("length", 1))) )
verify_args(args = list(foo = c(letters[1:3]), bar = 1:10), conditions =
list(foo = list(c("mode", "numeric"), c("n>", 5)), bar = list(c("mode",
"logical"), c("length", 5), c(">", 10), c("between", list(100, 200)),
c("choices", list("a", "b"))))) }
}
\arguments{
\item{args}{LIST of named arguments and their values, typically passed
directly from a function definition in the form \code{args = list(foo =
1:2, bar = c("a", "b", "c"))} or directly by passing \code{environment()}}

\item{conditions}{Nested LIST of conditions and values to check, with one
list item for each element in \code{args}. \itemize{ \item The first
element of each list should be a character scalar in the supported list.
\item The second element of each list should be the check values themselves
and may be of any type. } Multiple expectation conditions can be set for
each element of \code{args} in the form \itemize{ \item \code{conditions =
list(foo = list(c("mode", "numeric"), c("length", 2)), bar = list(c("mode",
"character"), c("n<", 5)))} } Currently supported expectations are:
\describe{ \item {"class"},{checks strict class expectation by direct
comparison with \code{class} to support object classes not supported with
the \code{is.x} or \code{is_x} family of functions; much stricter than a
"mode" check in that the requested check must be present in the return from
a call to \code{class} e.g. "list" will fail if a "data.frame" object is
passed} \item {"mode"},{checks class expectation by applying the
\code{is.X} or the \code{is_X} family of functions either directly or
flexibly depending on the value provided to \code{conditions} (e.g.
c("mode", "character") and c("mode", "is.character") and c("mode",
"is_character") all work equally well) and will default to the version you
provide explicitly (e.g. if you wish to prioritize "is_character" over
"is.character" simply provide "is_character" as the condition. Only those
modes able to be checked by this family of functions are supported. Run
function \code{mode_checks()} for a complete sorted list for your current
configuration.} \item {"length"},{length of values matches a pre-determined
exact length, typically a single value expectation (e.g. c("length",#'
1))} \item {"no_na"},{no NA values are present} \item {"n>"},{length of
values is greater than a given value - "n<" length of values is lesser than
a given value} \item {"n>="},{length of values is greater than or equal to
a given value} \item {"n<="},{length of values is lesser than or equal to a
given value} \item {">"},{numeric or date value is greater than a given
value} \item {"<" numeric or date value is greater than a given value}
\item {">="},{numeric or date value is greater than or equal to a given
value} \item {"<="},{ numeric or date value is lesser than or equal to a
given value} \item {"between"},{numeric or date values are bound within an
INCLUSIVE range (e.g. c("range", 1:5))} \item {"choices"},{provided values
are part of a selected list of expectations (e.g. \code{c("choices",
list(letters[1:3]))})} \item {"FUN"},{apply a function to the value and
check that the result is valid or that the function can be executed without
error; this evaluates the check condition using \code{tryCatch} via
\code{do.call} and so can also accept a full named list of arg values. This
is a strict check in the sense that a warning will also result in a failed
result, passing the warning (or error if the function fails) message back
to the user, but does not halt checks} }}

\item{from_fn}{CHR scalar of the function from which this is called, used if
logger is enabled and ignored if not; by default it will pull the calling
function's name from the call stack, but can be overwritten by a manual
entry here for better tracing. (default NULL)}

\item{silent}{LGL scalar of whether to silence warnings for individual
failiures, leaving them only as part of the output. (default: FALSE)}
}
\value{
LIST of the resulting values and checks, primarily useful for
  $message
}
\description{
This helper function checks arguments against a list of expectations. This
was in part inspired by the excellent \code{testthis} package and shares
concepts with the \code{Checkmate} package. However, this function performs
many of the common checks without additional package dependencies, and can be
inserted into other functions for a project easily with:
}
\details{
\preformatted{ arg_check <- verify_args( args       = as.list(environment()),
conditions = list( list(c("mode", "logical"), c("length", 1)), list( ... )))
}

and check the return with

\preformatted{ if (!arg_check$valid) cat(paste0(arg_check$messages, "\n"))}

where argument \code{conditions} describes the tests. This comes at the price
of readability as the list items in `\code{conditions} do not have to be
named, but can be to improve clarity. See more details below for argument
\code{conditions} to view which expectations are currently supported.

As this is a nested list condition check, it can also originate from any
source coercible to a list (e.g. JSON, XML, etc.) and this feature, along
with the return of human-meaningful evaluation strings, is particularly
useful for development of shiny applications. Values from other sources MUST
be coercible to a full list (e.g. if being parsed from JSON, use
\code{jsonlite::fromJSON(simplifyMatrix = FALSE))}

If logger is enabled, also provides some additional meaningful feedback.

At least one condition check is required for every element passed to `args`.
}
