% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/app_functions.R
\name{verify_args}
\alias{verify_args}
\title{Verify arguments for a function}
\usage{
verify_args(args = list(character_length_2 = c("a", "b")),
            conditions = list(character_length_2 = list(c("mode", "character"),
                                                        c("length", 3))
)
verify_args(args = list(boolean = c(TRUE, FALSE, TRUE)),
            conditions = list(list(c("mode", "logical"),
                                   c("length", 1)))
)
verify_args(args = list(foo = c(letters[1:3]),
                        bar = 1:10),
            conditions = list(foo = list(c("mode", "numeric"),
                                         c("n>", 5)),
                              bar = list(c("mode", "logical"),
                                         c("length", 5),
                                         c(">", 10),
                                         c("between", list(100, 200)),
                                         c("choices", list("a", "b"))))
)
}
\arguments{
\item{args}{LIST of named arguments and their values, typically passed
directly from a function definition in the form \code{args = list(foo =
1:2, bar = c("a", "b", "c"))} or directly by passing \code{environment()}}

\item{conditions}{Nested LIST of conditions and values to check, with one
list item for each element in \code{args}. \itemize{\item{The first
element of each list should be a character scalar in the supported list.} 
\item{The second element of each list should be the check values themselves
and may be of any type.}} Multiple expectation conditions can be set for
each element of \code{args} in the form \itemize{\item{\code{conditions =
list(foo = list(c("mode", "numeric"), c("length", 2)), bar = list(c("mode",
"character"), c("n<", 5)))}}} Currently supported expectations are:
\describe{\itemize{\item{\code{class}: {checks strict class expectation by direct
comparison with \code{class} to support object classes not supported with
the \code{is.x} or \code{is_x} family of functions; much stricter than a
"mode" check in that the requested check must be present in the return from
a call to \code{class} e.g. "list" will fail if a "data.frame" object is
passed}} \item{\code{mode}: {checks class expectation by applying the
\code{is.X} or the \code{is_X} family of functions either directly or
flexibly depending on the value provided to \code{conditions} (e.g.
\code{c("mode", "character")} and \code{c("mode", "is.character")} and \code{c("mode",
"is_character")} all work equally well) and will default to the version you
provide explicitly (e.g. if you wish to prioritize "is_character" over
"is.character" simply provide "is_character" as the condition. Only those
modes able to be checked by this family of functions are supported. Run
function \code{mode_checks()} for a complete sorted list for your current
configuration.}} \item{\code{length}: {length of values matches a pre-determined
exact length, typically a single value expectation (e.g. \code{c("length",#'
1)})}} \item{\code{no_na}: {no \code{NA} values are present}} \item{\code{n>}: {length of
values is greater than a given value - "n<" length of values is lesser than
a given value}} \item{\code{n>=}: {length of values is greater than or equal to
a given value}} \item{\code{n<=}: {length of values is lesser than or equal to a
given value}} \item{\code{>}: {numeric or date value is greater than a given
value}} \item{\code{<}: {numeric or date value is greater than a given value}}
\item{\code{>=}: {numeric or date value is greater than or equal to a given
value}} \item{\code{<=}: {numeric or date value is lesser than or equal to a
given value}} \item{\code{between}: {numeric or date values are bound within an
INCLUSIVE range (e.g. \code{c("range", 1:5)})}} \item{\code{choices}: {provided values
are part of a selected list of expectations (e.g. \code{c("choices",
list(letters[1:3]))})}} \item{\code{FUN}: {apply a function to the value and
check that the result is valid or that the function can be executed without
error; this evaluates the check condition using [tryCatch()] via
[do.call()] and so can also accept a full named list of arg values. This
is a strict check in the sense that a warning will also result in a failed
result, passing the warning (or error if the function fails) message back
to the user, but does not halt checks}}}}}

\item{from_fn}{CHR scalar of the function from which this is called, used if
logger is enabled and ignored if not; by default it will pull the calling
function's name from the call stack, but can be overwritten by a manual
entry here for better tracing. (default \code{NULL})}

\item{silent}{LGL scalar of whether to silence warnings for individual
failiures, leaving them only as part of the output. (default: \code{FALSE})}
}
\value{
LIST of the resulting values and checks, primarily useful for its
  \code{$valid} (\code{TRUE} if all checks pass or \code{FALSE} if any fail)
  and \code{$message} values.
}
\description{
This helper function checks arguments against a list of expectations. This
was in part inspired by the excellent [testthat](https://testthat.r-lib.org/)
package and shares concepts with the [Checkmate](https://mllg.github.io/checkmate/)
package. However, this function performs many of the common checks without
additional package dependencies, and can be inserted into other functions 
for a project easily with:
\preformatted{  arg_check <- verify_args(args = as.list(environment()),
  conditions = list(param1 = c("mode", "logical"), param2 = c("length", 1))}
and check the return with
\preformatted{  if (!arg_check$valid) cat(paste0(arg_check$messages, "\n"))}
where argument \code{conditions} describes the tests. This comes at the price
of readability as the list items in \code{conditions} do not have to be
named, but can be to improve clarity. See more details below for argument
\code{conditions} to view which expectations are currently supported.
As this is a nested list condition check, it can also originate from any
source coercible to a list (e.g. JSON, XML, etc.) and this feature, along
with the return of human-meaningful evaluation strings, is particularly
useful for development of shiny applications. Values from other sources MUST
be coercible to a full list (e.g. if being parsed from JSON, use
\code{jsonlite::fromJSON(simplifyMatrix = FALSE)})
}
\note{
If logger is enabled, also provides some additional meaningful feedback.

At least one condition check is required for every element passed to \code{args}.
}
