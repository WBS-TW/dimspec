% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/py_setup.R
\name{activate_py_env}
\alias{activate_py_env}
\title{Activate a python environment}
\usage{
activate_py_env(
  env_name = NULL,
  required_libraries = NULL,
  required_modules = NULL,
  log_ns = NULL,
  conda_path = NULL
)
}
\arguments{
\item{env_name}{CHR scalar of a python environment name to bind. The default,
NULL, will look for an environment variable named `PYENV_NAME`}

\item{required_libraries}{CHR vector of python libraries to include in the
environment, if building a new environment. Ignored if `env_name` is an
existing environment. The default, NULL, will look for an environment
variable named `PYENV_LIBRARIES`.}

\item{required_modules}{CHR vector of modules to be checked for availability
once the environment is activated. The default, NULL, will look for an
environment variable named `PYENV_MODULES`.}

\item{log_ns}{CHR scalar of the logging namespace to use, if any.}
}
\value{
LGL scalar of whether or not activate was successful
}
\description{
Programmatically setting up python bindings is a bit more convoluted than in
a standard script. Given the name of a Python environment, it either (1)
checks the provided `env_name` against currently installed environments and
binds the current session to it if found OR (2) installs a new environment
with [create_py_env] and activates it by calling itself.
}
\details{
It is recommended that project variables in `../config/env_py.R` and
`../config/env_glob.txt` be used to control most of the behavior of this
function. This works with both virtual and conda environments, though
creation of new environments is done in conda.
}
\note{
Where parameters are NULL, [rectify_null_from_env] will be used to get
  a value associated with it if they exist.
}
