<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Build an escaped SQL query</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for build_db_action"><tr><td>build_db_action</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Build an escaped SQL query</h2>

<h3>Description</h3>

<p>In most cases, issuing basic SQL queries is made easy by tidyverse compliant
functions such as [dplyr::tbl]. Full interaction with an SQLite database is a
bit more complicated and typically requires [DBI::dbExecute] and writing SQL
directly; several helpers exist for that (e.g. [glue::glue_sql]) but aren't
as friendly or straight forward when writing more complicated actions, and
still require directly writing SQL equivalents, routing through
[DBI::dbQuoteIdentifier] and [DBI::dbQuoteLiteral] to prevent SQL injection
attacks.
</p>


<h3>Usage</h3>

<pre>
build_db_action("insert", "table", values = list(col1 = "a", col2 = 2,
  col3 = "describe"), execute = FALSE) build_db_action("insert", "table",
  values = list(col1 = "a", col2 = 2, col3 = "describe"))
  build_db_action("get_id", "table", match_criteria = list(id = 2))
  build_db_action("delete", "table", match_criteria = list(id = 2))
  build_db_action("select", "table", columns = c("col1", "col2", "col3"),
  match_criteria = list(id = 2)) build_db_action("select", "table",
  match_criteria = list(sample_name = "sample 123"))
  build_db_action("select", "table", match_criteria = list(sample_name =
  list(value = "sample 123", exclude = TRUE)) build_db_action("select",
  "table", match_criteria = list(sample_name = "sample 123",
  sample_contributor = "Smith"), and_or = "AND", limit = 5)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>action</code></td>
<td>
<p>CHR scalar, of one &quot;INSERT&quot;, &quot;UPDATE&quot;, &quot;SELECT&quot;, &quot;GET_ID&quot;, or
&quot;DELETE&quot;</p>
</td></tr>
<tr valign="top"><td><code>table_name</code></td>
<td>
<p>CHR scalar of the table name to which this query applies</p>
</td></tr>
<tr valign="top"><td><code>db_conn</code></td>
<td>
<p>existing connection object (e.g. of class &quot;SQLiteConnection&quot;)</p>
</td></tr>
<tr valign="top"><td><code>column_names</code></td>
<td>
<p>CHR vector of column names to include (default NULL)</p>
</td></tr>
<tr valign="top"><td><code>values</code></td>
<td>
<p>LIST of CHR vectors with values to INSERT or UPDATE (default
NULL)</p>
</td></tr>
<tr valign="top"><td><code>limit</code></td>
<td>
<p>INT scalar of the maximum number of rows to return  (default
NULL)</p>
</td></tr>
<tr valign="top"><td><code>group_by</code></td>
<td>
<p>CHR vector of columns by which to group (default NULL)</p>
</td></tr>
<tr valign="top"><td><code>order_by</code></td>
<td>
<p>named CHR vector of columns by which to order, with names
matching columns and values indicating whether to sort ascending (default
NULL)</p>
</td></tr>
<tr valign="top"><td><code>distinct</code></td>
<td>
<p>LGL scalar of whether or not to apply the DISTINCT clause to
all match criteria (default FALSE)</p>
</td></tr>
<tr valign="top"><td><code>get_all_columns</code></td>
<td>
<p>LGL scalar of whether to return all columns; will be
set to TRUE automatically if no column names are provided (default FALSE)</p>
</td></tr>
<tr valign="top"><td><code>execute</code></td>
<td>
<p>LGL scalar of whether or not to immediately execute the build
query statement (default TRUE)</p>
</td></tr>
<tr valign="top"><td><code>single_column_as_vector</code></td>
<td>
<p>LGL scalar of whether to return results as a
vector if they consist of only a single column (default TRUE)</p>
</td></tr>
<tr valign="top"><td><code>log_ns</code></td>
<td>
<p>CHR scalar of the logging namespace to use during execution
(default: &quot;db&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to ease that by taking care of most of the
associated logic and enabling routing through other functions, or picking up
arguments from within other function calls.
</p>


<h3>Value</h3>

<p>CHR scalar of the constructed query
</p>


</body></html>
