% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NIST_import_routines.R
\name{full_import}
\alias{full_import}
\title{Import one or more files from the NIST Method Reporting Tool for NTA}
\usage{
full_import(
  import_object = NULL,
  file_name = NULL,
  db_conn = con,
  exclude_missing_required = FALSE,
  stop_if_missing_required = TRUE,
  include_if_missing_recommended = FALSE,
  stop_if_missing_recommended = TRUE,
  ignore_extra = TRUE,
  ignore_insert_conflicts = TRUE,
  requirements_obj = "import_requirements",
  method_in = "massspectrometry",
  ms_methods_table = "ms_methods",
  instrument_properties_table = "instrument_properties",
  sample_info_in = "sample",
  sample_table = "samples",
  contributor_in = "data_generator",
  contributors_table = "contributors",
  sample_aliases = NULL,
  generation_type = NULL,
  generation_type_norm_table = ref_table_from_map(sample_table, "generation_type"),
  mass_spec_in = "massspectrometry",
  chrom_spec_in = "chromatography",
  mobile_phases_in = "chromatography",
  qc_method_in = "qcmethod",
  qc_method_table = "qc_methods",
  qc_method_norm_table = ref_table_from_map(qc_method_table, "name"),
  qc_references_in = "source",
  qc_data_in = "qc",
  qc_data_table = "qc_data",
  carrier_mix_names = NULL,
  id_mix_by = "^mp*[0-9]+",
  mix_collection_table = "carrier_mix_collections",
  mobile_phase_props = list(in_item = "chromatography", db_table = "mobile_phases", props
    = c(flow = "flow", flow_units = "flowunits", duration = "duration", duration_units =
    "durationunits")),
  carrier_props = list(db_table = "carrier_mixes", norm_by =
    ref_table_from_map("carrier_mixes", "component"), alias_in = "carrier_aliases", props
    = c(id_by = "solvent", fraction_by = "fraction")),
  additive_props = list(db_table = "carrier_additives", norm_by =
    ref_table_from_map("carrier_additives", "component"), alias_in = "additive_aliases",
    props = c(id_by = "add$", amount_by = "_amount", units_by = "_units")),
  exclude_values = c("none", "", NA),
  peaks_in = "peak",
  peaks_table = "peaks",
  software_timestamp = NULL,
  software_settings_in = "msconvertsettings",
  ms_data_in = "msdata",
  ms_data_table = "ms_data",
  unpack_spectra = FALSE,
  unpack_format = c("separated", "zipped"),
  ms_spectra_table = "ms_spectra",
  linkage_table = "conversion_software_peaks_linkage",
  settings_table = "conversion_software_settings",
  as_date_format = "\%Y-\%m-\%d \%H:\%M:\%S",
  format_checks = c("ymd_HMS", "ydm_HMS", "mdy_HMS", "dmy_HMS"),
  min_datetime = "2000-01-01 00:00:00",
  fragments_in = "annotation",
  fragments_table = "annotated_fragments",
  fragments_sources_table = "fragment_sources",
  fragments_norm_table = "norm_fragments",
  citation_info_in = "fragment_citation",
  inspection_info_in = "fragment_inspections",
  inspection_table = "fragment_inspections",
  generate_missing_aliases = TRUE,
  fragment_aliases_in = "fragment_aliases",
  fragment_aliases_table = "fragment_aliases",
  fragment_alias_type_norm_table = ref_table_from_map(fragment_aliases_table,
    "alias_type"),
  inchi_prefix = "InChI=1S/",
  rdkit_ref = ifelse(exists("PYENV_REF"), PYENV_REF, "rdk"),
  rdkit_ns = "rdk",
  rdkit_make_if_not = TRUE,
  rdkit_aliases = c("inchi", "inchikey"),
  mol_to_prefix = "MolTo",
  mol_from_prefix = "MolFrom",
  type = "smiles",
  compounds_in = "compounddata",
  compounds_table = "compounds",
  compound_category = NULL,
  compound_category_table = "compound_categories",
  compound_aliases_in = "compound_aliases",
  compound_aliases_table = "compound_aliases",
  compound_alias_type_norm_table = ref_table_from_map(compound_aliases_table,
    "alias_type"),
  fuzzy = FALSE,
  case_sensitive = TRUE,
  ensure_unique = TRUE,
  require_all = FALSE,
  import_map = IMPORT_MAP,
  log_ns = "db"
)
}
\arguments{
\item{import_object}{nested LIST object of JSON data to import; this import
routine was built around output from the NTA MRT (default: NULL) - note you
may supply either import object or file_name}

\item{file_name}{external file in JSON format of data to import;  this import
routine was built around output from the NTA MRT (default: NULL) - note you
may supply either import object or file_name}

\item{db_conn}{connection object (default: con)}

\item{exclude_missing_required}{LGL scalar of whether or not to skip imports
missing required information (default: FALSE); if set to TRUE, this will
override the setting for `stop_if_missing_required` and the import will
continue with logging messages for which files were incomplete}

\item{stop_if_missing_required}{LGL scalar of whether or not to to stop the
import routine if a file is missing required information (default: TRUE)}

\item{include_if_missing_recommended}{LGL scalar of whether or not to include
imports missing recommended information (default: FALSE)}

\item{stop_if_missing_recommended}{LGL scalar of whether or not to to stop
the import routine if a file is missing recommended information (default:
TRUE)}

\item{ignore_extra}{LGL scalar of whether to ignore extraneous import
elements or stop the import process (default: TRUE)}

\item{ignore_insert_conflicts}{LGL scalar of whether to ignore insert
conflicts during the qc methods and qc data import steps (default: TRUE)}

\item{requirements_obj}{CHR scalar of the name of an R object holding import
requirements; this is a convenience shorthand to prevent multiple imports
from parameter `file_name` (default: "import_requirements")}

\item{method_in}{CHR scalar name of the `obj` list containing method
information}

\item{ms_methods_table}{CHR scalar name of the database table containing
method information}

\item{instrument_properties_table}{CHR scalar name of the database table
holding instrument property information for a given method (default:
"instrument_properties")}

\item{sample_info_in}{CHR scalar name of the element within `import_object`
containing samples information}

\item{sample_table}{CHR scalar name of the database table holding sample
information (default: "samples")}

\item{contributor_in}{CHR scalar name of the element within
`import_object[[sample_info_in]]` containing contributor information
(default: "data_generator")}

\item{contributors_table}{CHR scalar name of the database table holding
contributor information (default: "contributors")}

\item{sample_aliases}{named CHR vector of aliases with names matching the
alias, and values of the alias reference e.g. c("ACU1234" = "NIST
Biorepository GUAID") which can be virutally any reference text; it is
recommended that the reference be to a resolver service if connecting with
external data sources (default: NULL)}

\item{generation_type}{CHR scalar of the type of data generated for this
sample (e.g. "empirical" or "in silico"). The default (NULL) will assign
based on `generation_type_default`; any other value will override the
default value and be checked against values in `geneation_type_norm_table`}

\item{generation_type_norm_table}{CHR scalar name of the database table
normalizing sample generation type (default: "empirical")}

\item{mass_spec_in}{CHR scalar name of the element in `obj` holding mass
spectrometry information (default: "massspectrometry")}

\item{chrom_spec_in}{CHR scalar name of the element in `obj` holding
chromatographic information (default: "chromatography")}

\item{mobile_phases_in}{CHR scalar name of the database table holding mobile
phase and chromatographic information (default: "chromatography")}

\item{qc_method_in}{CHR scalar name of the import object element containing
QC method information (default: "qcmethod")}

\item{qc_method_table}{CHR scalar of the database table name holding QC
method check information (default: "qc_methods")}

\item{qc_method_norm_table}{CHR scalar name of the database table normalizing
QC methods type (default: "norm_qc_methods_name")}

\item{qc_references_in}{CHR scalar of the name in `obj[[qc_method_in]]` that
contains the reference or citation for the QC protocol (default: "source")}

\item{carrier_mix_names}{CHR vector (optional) of carrier mix collection
names to assign, the length of which should equal 1 or the length of
discrete carrier mixtures; the default, NULL, will automatically assign
names as a function of the method and sample id.}

\item{id_mix_by}{regex CHR to identify mobile phase mixtures (default:
"^mp*[0-9]+" matches the generated mixture names)}

\item{mix_collection_table}{CHR scalar name of the mix collections table
(default: "carrier_mix_collections")}

\item{mobile_phase_props}{LIST object describing how to import the mobile
phase table containing: in_item: CHR scalar name of the `obj` name
containing chromatographic information (default: "chromatography");
db_table: CHR scalar name of the mobile phases table (default:
"mobile_phases"); props: named CHR vector of name mappings with names equal
to database columns in `mobile_phase_props$db_table` and values matching
regex to match names in `obj[[mobile_phase_props$in_item]]`}

\item{carrier_props}{LIST object describing how to import the mobile phase
table containing: db_table: CHR scalar name of the mobile phases table
(default: "mobile_phases"); norm_table: CHR scalar name of the table used
to normalize carriers (default: "norm_carriers"); alias_table: CHR scalar
name of the table containing carrier aliases to search (default:
"carrier_aliases"); props: named CHR vector of name mappings with names
equal to database columns in `carrier_props$db_table` and values matching
regex to match names in `obj[[mobile_phase_props$in_item]]`, and an extra
element named `id_by` containing regex used to match names in the import
object indicate a carrier (e.g. "solvent")}

\item{additive_props}{LIST object describing how to import the mobile phase
table containing: db_table: CHR scalar name of the mobile phases table
(default: "mobile_phases"); norm_table: CHR scalar name of the table used
to normalize carriers (default: "norm_additives"); alias_table: CHR scalar
name of the table containing carrier aliases to search (default:
"additive_aliases"); props: named CHR vector of name mappings with names
equal to database columns in `additive_props$db_table` and values matching
regex to match names in `obj[[mobile_phase_props$in_item]]`
`obj[[mobile_phase_props$in_item]][[mobile_phase_props$db_table]]`, and an
extra element named `id_by` containing regex used to match names in the
import object indicate an additive (e.g. "add$")}

\item{exclude_values}{CHR vector indicating which values to ignore in `obj`
(default: c("none", "", NA))}

\item{peaks_in}{CHR scalar name of the element within `import_object`
containing peak information}

\item{peaks_table}{CHR scalar name of the database table holding sample
information (default: "samples")}

\item{ms_data_in}{CHR scalar of the named component of `obj` holding mass
spectral data (default: "msdata")}

\item{ms_data_table}{CHR scalar name of the table holding packed spectra in
the database (default: "ms_data")}

\item{unpack_spectra}{LGL scalar indicating whether or not to unpack spectral
data to a long format (i.e. all masses and intensities will become a single
record) in the table defined by `ms_spectra_table` (default: FALSE)}

\item{unpack_format}{CHR scalar of the type of data packing for the spectra,
one of "separated" (default) or "zipped"}

\item{ms_spectra_table}{CHR scalar name of the table holding long form
spectra in the database (default: "ms_spectra")}

\item{fragments_in}{CHR scalar name of the `obj` component holding annotated
fragment information (default: "annotation")}

\item{fragments_table}{CHR scalar name of the database table holding
annotated fragment information (default: "annotated_fragments")}

\item{fragments_sources_table}{CHR scalar name of the database table holding
fragment source (e.g. generation) information (default: "fragment_sources")}

\item{fragments_norm_table}{CHR scalar name of the database table holding
normalized fragment identities (default: obtains this from the result of a
call to [er_map] with the table name from `fragments_table`)}

\item{citation_info_in}{CHR scalar name of the `obj` component holding
fragment citation information (default: "fragment_citation")}

\item{inspection_info_in}{CHR scalar name of the `obj` component holding
fragment inspection information (default: "fragment_inspections")}

\item{inspection_table}{CHR scalar name of the database table holding
fragment inspection information (default: "fragment_inspections")}

\item{generate_missing_aliases}{LGL scalar determining whether or not to
generate machine readable expressions (e.g. InChI) for fragment aliases
from RDKit (requires RDKit activation; default: FALSE); see formals list
for [add_rdkit_aliases]}

\item{fragment_aliases_in}{CHR scalar name of the `obj` component holding
fragment aliases (default: "fragment_aliases")}

\item{fragment_aliases_table}{CHR scalar name of the database table holding
fragment aliases (default: "fragment_aliases")}

\item{fragment_alias_type_norm_table}{CHR scalar name of the alias reference
normalization table, by default the return of
\code{ref_table_from_map(fragment_aliases_table, "alias_type")}}

\item{rdkit_ref}{CHR scalar OR R object of an RDKit binding (default NULL
goes to "rdk" for convenience with other pipelines in this project)}

\item{mol_to_prefix}{CHR scalar of the prefix to identify an RDKit function
to create an alias from a mol object (default: "MolTo")}

\item{mol_from_prefix}{CHR scalar of the prefix to identify an RDKit function
to create a mol object from`identifiers` (default: "MolFrom")}

\item{type}{The type of chemical structure notation (default: SMILES)}

\item{compounds_in}{CHR scalar name in `obj` holding compound data (default:
"compounddata")}

\item{compounds_table}{CHR scalar name the database table holding compound
data (default: "compounds")}

\item{compound_category}{CHR or INT scalar of the compound category (either a
direct ID or a matching category label in `compound_category_table`)
(default: NULL)}

\item{compound_category_table}{CHR scalar name the database table holding
normalized compound categories (default: "compound_categories")}

\item{compound_aliases_in}{CHR scalar name of where compound aliases are
located within the import (default: "compound_aliases"), passed to
[resolve_compounds] as "norm_alias_table"}

\item{compound_aliases_table}{CHR scalar name of the alias reference table to
use when assigning compound aliases (default: "compound_aliases") passed to
[resolve_compounds] as "compounds_table"}

\item{compound_alias_type_norm_table}{CHR scalar name of the alias reference
normalization table, by default the return of
\code{ref_table_from_map(compound_aliases_table, "alias_type")}}

\item{fuzzy}{LGL scalar of whether to do a "fuzzy" match in the sense that
values provided are wrapped in an SQL "LIKE '%value%'" clause; overrides
the `case_sensitive` setting if TRUE (default: FALSE).}

\item{case_sensitive}{LGL scalar of whether to match on a case sensitive
basis (the default TRUE searches for values as-provided) or whether to
coerce value matches by upper, lower, sentence, and title case matches}

\item{ensure_unique}{LGL scalar of whether or not to first check that the
values provided form a new unique record (default: TRUE)}

\item{require_all}{LGL scalar of whether to require all columns (except the
assumed primary key column of "id") or only those defined as "NOT NULL"
(default: TRUE requires the presence of all columns in the table)}

\item{import_map}{data.frame object of the import map (e.g. from a CSV)}

\item{log_ns}{CHR scalar of the logging namespace to use (default: "db")}
}
\value{
Console logging if enabled and interactive prompts when user
  intervention is required. There is no formal return as it executes database
  actions.
}
\description{
This function serves as a single entry point for data imports. It is
predicated upon the NIST import routine defined here and relies on several
assumptions. It is intended ONLY as an interactive manner of importing n data
files from the NIST Method Reporting Tool for NTA (MRT NTA).
}
\details{
Import files should be in JSON format as created by the MRT NTA. Examples are
provided in the "example" directory of the project.

Defaults for this release are set throughout as of the latest database
schema, but left here as arguments in case those should change, or slight
changes are made to column and table names.
}
\note{
Many calls within this function are executed as do.call with a filtered
  argument list based on the names of formals for the called function.
  Several arguments to those functions are also left as the defaults set
  there; names must match exactly to be passed in this manner. See the list
  of inherited parameters.
}
