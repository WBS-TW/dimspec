% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/app_functions.R
\name{get_component}
\alias{get_component}
\title{Resolve components from a list or named vector}
\usage{
get_component(obj, obj_component, silence = TRUE, log_ns = "global", ...)
}
\arguments{
\item{obj}{LIST or NAMED vector in which to find \code{obj_component}}

\item{obj_component}{CHR vector of named elements to find in \code{obj}}

\item{silence}{LGL scalar indicating whether to silence recursive messages,
which may be the same for each element of \code{obj} (default: TRUE)}

\item{log_ns}{CHR scalar of the logging namespace to use (default: "db")}

\item{...}{Additional arguments passed to/from the ellipsis parameter of
calling functions. If named, names are preserved.}
}
\value{
LIST object containing the elements of \code{obj}
}
\description{
Call this to pull a component named \code{obj_component} from a list or named
vector provided as \code{obj} and optionally use [tack_on] to append to it. This
is intended to ease the process of pulling specific components from a list
for further treatment in the import process by isolating that component.
}
\details{
This is similar in scope to [purrr::pluck] in many regards, but always
returns items with names, and will search an entire list structure, including
data frames, to return all values associated with that name in individual
elements.
}
\note{
This is a recursive function.

If ellipsis arguments are provided, they will be appended to each
  identified component via [tack_on]. Use with caution, but this can be
  useful for appending common data to an entire list (e.g. a datetime stamp
  for logging processing time or a processor name, human or software).
}
\examples{
get_component(list(a = letters, b = 1:10), "a")
get_component(list(ex = list(a = letters, b = 1:10), ex2 = list(c = 1:5, a = LETTERS)), "a")
get_component(list(a = letters, b = 1:10), "a", c = 1:5)

}
